<!DOCTYPE html>
<html>
  <head>
    <title>midsockets :: documentation</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <script src="jquery-1.9.1.js"></script>
    <script src="highlight.js"></script>
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div id="wrapper">
      <div id="page-title">
        <h1>midsockets</h1>
        <hr>
      </div>

      <p>midsockets is a wrapper around sockjs to provide middleware, routing, and a promise-like
        request api.</p>

      <p>see the <a href="./api/index.html">api docs</a> for more info</p>

      <h2>creating a chat app:</h2>

      <h3>server</h3>

      <p>Create a router which will respond to incoming routes. Mount this router on midsockets.</p>
      <pre>
        <code>
  var api = new midsockets.Router();
  var sockapp = midsockets("/midsockets");
  sockapp.mount("/chat",api);
        </code>
      </pre>

      <p>You will need to attach it to an HTTP server.</p>
      <pre>
        <code>
  var server = http.createServer(/* e.g., express or connect app */);
  sockapp.listen(server);
        </code>
      </pre>

      

      <p>The router can listen for incoming requests. The route passed to on can include any levels of path matches, as well as /:param/ matchers. On most requests, you would return a result by calling res.resolve(). We do not on this subscription route. An unresolved-request will stay open, and events can be emitted on it until it is closed.</p>
      <p>We can create an instance of midsockets.Events() for our chat room message pump, as it has a pretty good implementation of events and works with res.listenTo.</p>
      <pre>
        <code>
  var chat_events = new midsockets.Events();

  api.on("/chat/subscription",function(req,res){
    res.listenTo(chat_events,"message",{as: "message"});
  });
        </code>
      </pre>

      <p>Our /send endpoint is easy. You can see the data passed to RequestClient#post(...) is attached to req.data.</p>
      <pre>
        <code>
  api.on("/chat/send",function(req,res){
    chat_events.emit("message",{body: req.data.body});
    res.resolve();
  });
        </code>
      </pre>

      <h3>client</h3>

      <p>Initialize midsockets with the midsockets() function, and get a RequestClient to use the promises api.</p>

      <pre>
        <code>
  window.Api = midsockets("/midsockets").requestClient()
        </code>
      </pre>

      <p>You can create a child RequestGhost (shim for RequestClient) by calling requester() on a RequestClient or RequestGhost. This is useful for removing absolute paths from your implementation. For example, you could pass the result of Api.requester("/chat/room_name") to a ChatRoom class in a more sophisticated application.</p>

      <pre>
        <code>
  var chat = Api.requester("/chat");
        </code>
      </pre>

      <p>A get() returns a promise, the two most important functions of which are RequestPromise#done(success_callback,error_callback) and RequestPromise#on([event_name],callback). To get our chat subscription, we would .get() it from the RequestClient and listen to events emited on it until it is resolved.</p>

      <pre>
        <code>
  chat.get("/subscription").on("message",function(obj){
    console.log("someone said: "+obj.body);
  }).done(function(){
    console.log("chat has closed");
  });
        </code>
      </pre>

      <p>Since sending a message requires data to be attached, use the RequestClient#post(route,data) method.</p>

      <pre>
        <code>

  window.sendMessage = function sendMessage(text){
    chat.post("/send",{body:text}).done(function(){
      console.log("message "+text+" has been sent");
    });
  };
        </code>
      </pre>
    </div>
  </body>
</html>
